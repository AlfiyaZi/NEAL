Advanced Example
================

Given the following snippet:

.. code-block:: swift

  func expensive() {
    /* ... */
  }

  class B { /* ... */ }

  class A : B {
    override init() {
      expensive()
    }
  }

Let's create a rule that checks for subclasses of `B` that make to calls to `expensive` from initialisers.

Just like in our simpler example, we start by inspecting the AST of a snippet that violates our rule-to-be:

.. code-block:: bash

  $ echo 'class A : B { override init() { expensive() } }' | neal --stdin swift --print-ast

.. code-block:: swift

  ClassDeclaration {
    ClassName = Identifier { Value = "A" }
    TypeInheritanceClause = [
      TypeIdentifier {
        TypeName = Identifier { Value = "B" }
      }
    ]
    ClassBody = [
      InitializerDeclaration {
        Override = true
        InitializerBody = [
          CallExpression {
            Callee = Identifier { Value = "expensive" }
            Arguments = []
          }]}]}

Based on the names in the AST, what we want is: A ``ClassDeclaration``, with a ``TypeInheritanceClause`` that contains ``B``, and which has an ``InitializerDeclaration`` that contains ``CallExpression`` whose ``Callee`` is ``expensive``.

Let's start writing our rule: again we start by giving it a name and choosing a provider:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::
  }

Now, from looking at a notes above, the top node in our rule needs to be a `ClassDeclaration` that inherits from `B`:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::ClassDeclaration where /* inherits from B */ {
    }
  }

We could write this condition in terms of the nodes of ``ClassDeclaration``, but luckily the Swift provider gives us an ``inheritsFrom`` helper that does just that:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::ClassDeclaration where inheritsFrom("B") {
    }
  }

Next we need to look inside the ``InitializerDeclaration``, so we add it to our rule:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::ClassDeclaration where inheritsFrom("B") {
      InitializerDeclaration {
      }
    }
  }

Now, to the part that actually violates our rule, we check that there exists a call to `expensive`:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::ClassDeclaration where inheritsFrom("B") {
      InitializerDeclaration {
        CallExpression where Callee == "expensive" {
        }
      }
    }
  }

And last but not least, we trigger an error with some helpful message:

.. code-block:: rust

  rule NoExpensiveSubclassesOfB {
    Swift::ClassDeclaration where inheritsFrom("B") {
      InitializerDeclaration {
        CallExpression where Callee == "expensive" {
          fail("Don't call `expensive` from initialisers of subclasses of `B` because <...>. Use <...> instead.")
        }
      }
    }
  }

Now we can test our rule:

.. code-block:: bash

  $ neal --rules test.rules test.swift
  [1 of 1]: Analysing test.swift
  On file test.swift: (NoExpensiveSubclassesOfB)

     7 | class A : B {
     8 |   override init() {
     9 |     expensive()
     ~ |               ^
    10 |   }
    11 | }

  error: Don't call `expensive` from initialisers of subclasses of `B` because <...>. Use <...> instead.

Done, now your code base is safe from expensive subclass of `B`!
